* 1. FUNCTIONS & ARGUMENTS
** 1.1 'ONESHOT' FUNCTIONS
*** 1.1.1 ~play~ and ~sleep~
- ~play arg~
  - options: ~amp~ / ~attack~ / ~release~
- ~sleep arg~

**** EXAMPLES
#+BEGIN_SRC ruby
play 70
sleep 1
play 75
#+END_SRC

#+BEGIN_SRC ruby
play 70, release: 0.2
sleep 0.25
play 71, release: 0.2
sleep 0.25
play 83, release: 0.2
sleep 0.25

play 81, release: 4
play 79, release: 4

sleep 2

play 81, release: 2
play 78, release: 2
#+END_SRC

#+BEGIN_SRC ruby
play 60
play 65
play 70

sleep 1

play 62, attack: 0.1, release: 3
sleep 0.2
play 65, attack: 0.1, release: 3
sleep 0.2
play 69, attack: 0.1, release: 3
sleep 0.2
play 72, attack: 0.1, release: 3
play 77, attack: 0.1, release: 3
#+END_SRC

#+BEGIN_SRC ruby
play 90, attack: 30
play 88, attack: 30
play 86, attack: 30

play 89, attack: 10, release: 5
play 87, attack: 10, release: 5
play 85, attack: 10, release: 5

sleep 25

play 91, attack: 5, release: 5
play 92, attack: 5, release: 5
play 93, attack: 5, release: 10
play 94, attack: 5, release: 5
#+END_SRC


*** 1.1.2 ~sample~
- ~sample arg~
  - options: ~rate~, ~beat_stretch~

**** EXAMPLES
!! watch out for the position of the colons "*:*" on this one

#+BEGIN_SRC ruby
sample :loop_amen_full
#+END_SRC

- What's /Amen Break/? -> https://www.youtube.com/watch?v=FFKMtv8tU0U

#+BEGIN_SRC ruby
sample :loop_amen_full, rate: 1.5
#+END_SRC

#+BEGIN_SRC ruby
sample :loop_amen_full, rate: -1
#+END_SRC

#+BEGIN_SRC ruby
##| uncomment lines 4 through 8 one at a time

sample :guit_e_fifths
##| sample :guit_e_fifths, rate: 1.01
##| sample :guit_e_fifths, rate: 1.02
##| sample :guit_e_fifths, rate: 1.03
##| sample :guit_e_fifths, rate: 1.04
##| sample :guit_e_fifths, rate: 1.05
#+END_SRC

#+BEGIN_SRC ruby
##| without beat_stretch
sample :loop_breakbeat
sample :loop_compus
sleep 4
sample :loop_breakbeat
sample :loop_compus

##| with beat_stretch
##| sample :loop_breakbeat, beat_stretch: 4
##| sample :loop_compus, beat_stretch: 4
##| sleep 4
##| sample :loop_breakbeat, beat_stretch: 4
##| sample :loop_compus, beat_stretch: 4
#+END_SRC

#+BEGIN_SRC ruby
sample "~/Downloads/samples/forest_02.wav"
#+END_SRC

#+BEGIN_SRC ruby
##| this sample has 21 seconds (so it lasts approximately 21 beats)
sample "~/Downloads/samples/forest_02.wav"

##| now it lasts for 210 beats...
##| sample "~/Downloads/samples/forest_02.wav", beat_stretch: 210

##| which is pretty much the same as this...
##| sample "~/Downloads/samples/forest_02.wav", rate: 0.1
#+END_SRC

#+BEGIN_SRC ruby
sample "~/Downloads/samples/monge.wav", rate: 1
sleep 2
sample "~/Downloads/samples/monge.wav", rate: 1.5
sleep 10
sample "~/Downloads/samples/monge.wav", rate: 2, amp: 0.8
#+END_SRC

#+BEGIN_SRC ruby
sample :bass_drop_c, rate: 0.2
sample :bass_hard_c, rate: 0.4, release: 1

sleep 4

sample :loop_electric, beat_stretch: 2
sleep 2
sample :loop_electric, beat_stretch: 2
sleep 2

sample :vinyl_rewind

sample :perc_impact2, rate: -0.3
sleep 3
sample :perc_impact1
#+END_SRC

Tudo junto e misturado...

#+BEGIN_SRC ruby
sample :guit_harmonics, beat_stretch: 8
sample :ambi_glass_hum, beat_stretch: 8
play 64, release: 2
sleep 0.1
play 63, release: 2
play 62, release: 3

sleep 4

sample :ambi_haunted_hum, rate: 0.5
play 90, attack: 2, release: 2, amp: 0.05
sleep 2
play 88, attack: 2, release: 4, amp: 0.05
#+END_SRC

*** TODO /OTHER FUNCTIONS AND OPTS TO EXPLORE/
~play_chord~

*** TODO /CONCEITOS IMPORTANTES/
- linguagem só entende palavras que fazem parte do seu vocabulário
- a página inteira de código é lida de uma vez, na ordem em que está escrito (a não ser que seja um comentário).
- funções ("o que")
- argumentos ("como")
  - números são abstrações. só significam alguma coisa quando atribuimos um significado pra eles
  - em outras palavras: sempre se perguntar "o que significa o valor do argumento?"
  - nesse momento, nem todos argumentos são obrigatórios. sonic pi chama de options, ou opts (mas são só para os synths...)
- RTFM

** 1.2 GLOBAL BEHAVIOUR CHANGING FUNCTIONS
*** 1.2.1 ~use_synth~
- ~use_synth arg~
  - options: synth specific (with a few opts shared between many different synths)

**** EXAMPLES

#+BEGIN_SRC ruby
use_synth :prophet
play 50
#+END_SRC

#+BEGIN_SRC ruby
use_synth :blade
play 52
play 59
play 66
play 64

sleep 1

play 52
play 59
play 66
play 63
#+END_SRC

#+BEGIN_SRC ruby
use_synth :beep
play 70
sleep 1
play 74
sleep 2

use_synth :chipbass
play 75
sleep 0.5
play 76
sleep 1

use_synth :dark_ambience
play 77, amp: 10
sleep 1
play 78, amp: 10
#+END_SRC

#+BEGIN_SRC ruby
# this option makes a difference in the sound between notes...
use_synth :fm
play 50, depth: 1
sleep 1
play 50, depth: 8
sleep 1
play 50, depth: 30
sleep 1
play 50, depth: 100
sleep 1

# but this doesn't (even if sonic pi doesn't accuse any error...)
##| use_synth :prophet
##| play 50, depth: 1
##| sleep 1
##| play 50, depth: 8
##| sleep 1
##| play 50, depth: 30
##| sleep 1
##| play 50, depth: 100
#+END_SRC

*** 1.2.2 ~use_synth_defaults~
- ~use_synth_defaults arg~
  - options: synth specific (with a few opts shared between many different synths)

**** EXAMPLES
Let's refactor some of the first examples, but now using ~use_synth_defaults~
#+BEGIN_SRC ruby
use_synth_defaults release: 0.2
play 70
sleep 0.25
play 71
sleep 0.25
play 83
sleep 0.25

use_synth_defaults release: 4
play 81
play 79

sleep 2

use_synth_defaults release: 2
play 81
play 78
#+END_SRC

#+BEGIN_SRC ruby
play 60
play 65
play 70

sleep 1

use_synth_defaults attack: 0.1, release: 3

play 62
sleep 0.2
play 65
sleep 0.2
play 69
sleep 0.2
play 72
play 77
#+END_SRC

Tudo junto e misturado...

#+BEGIN_SRC ruby
use_synth :fm
play 67, release: 6, depth: 100, amp: 0.8

use_synth :dsaw
use_synth_defaults release: 5, detune: 0.2

play 67
play 70
play 74

sleep 5

use_synth :prophet
use_synth_defaults release: 0.2

play 67
sleep 0.2
play 70
sleep 0.2
play 74
sleep 0.2
play 67
play 70
play 74
#+END_SRC

* 2. BLOCKS
** 2.1 ~LOOP DO/END~

- ~loop do <code> end~

**** EXAMPLES
#+BEGIN_SRC ruby
loop do
  sample :bd_fat
  sleep 1
end
#+END_SRC

#+BEGIN_SRC ruby
loop do
  play 72
  sleep 1
end

play 666 #this never get's evaluated
#+END_SRC

#+BEGIN_SRC ruby
# All play no sleep makes loop a dull thread...
loop do
  play 70
end
#+END_SRC


** 2.2 ~n.TIMES DO/END~
- ~n.times do <code> end~

**** EXAMPLES

#+BEGIN_SRC ruby
8.times do
  sample :drum_cymbal_closed
  sleep 0.1
end

4.times do
  sample :drum_cymbal_open
  sleep 0.4
end
#+END_SRC

#+BEGIN_SRC ruby
use_bpm 112
use_synth_defaults release: 0.3

2.times do
  play 50
  sleep 0.5
  play 50
  sleep 0.5
  play 50
  sleep 0.5
  play 50
  sleep 0.25
  play 50
  sleep 0.25
  play 50, release: 0.5
  sleep 0.5
  play 43, release: 1
  sleep 2
end

use_synth :piano
use_synth_defaults release: 1

play 74
play 79
play 86

sleep 1

play 74
play 81
play 86
#+END_SRC


** 2.3 NESTING

*** 2.3.1 LOOP INCEPTION

#+BEGIN_SRC ruby
loop do
  8.times do
    sample :drum_cymbal_closed
    sleep 0.1
  end
  
  4.times do
    sample :drum_cymbal_open
    sleep 0.4
  end
end
#+END_SRC

#+BEGIN_SRC ruby
use_bpm 76

loop do
  2.times do
    sample :drum_heavy_kick
    sleep 0.5
  end
  
  sample :drum_snare_hard
  sleep 1
end
#+END_SRC

- Without playing the next example, can you analize it and tell:
  - Since the outer ~loop do/end~ block has no ~sleep~ (did you noticed?), does that mean the code will crash and not play at all?
  - If you think it won't crash, how many seconds after the beggining will ~play 90~ and ~play 86~ be heard?
#+BEGIN_SRC ruby
loop do
  sample :loop_compus, beat_stretch: 8
  
  2.times do
    sample :bass_drop_c, amp: 0.5, beat_stretch: 2
    sleep 2
    sample :bass_hard_c, amp: 0.5, beat_stretch: 2
    sleep 2
    
    play 90
  end
  
  play 86
end
#+END_SRC

*** 2.3.2 EFFECTS


* 3. RANDOMIZATION

- rrand(x, y)
  - give two values, and a random number inside the /range/ will be chosen

** FUNCTION AS ARGUMENT FOR OTHER FUNCTIONS
#+BEGIN_SRC ruby
print rrand(20, 30)
#+END_SRC

#+BEGIN_SRC ruby
loop do
  sample :perc_bell, rate: (rrand 0.125, 1.5)
  sleep rrand(0.2, 2)
end
#+END_SRC

#+BEGIN_SRC ruby
use_synth :tb303
use_synth_defaults release: 0.2

loop do
  play 40, cutoff: rrand(50, 90)
  sleep 0.2
end
#+END_SRC

** CHOOSE A NUMBER
- [].choose 
  - give a list of itens inside [brackets], and /only/ itens from that list will be chosen

#+BEGIN_SRC ruby
loop do
  sample :drum_bass_hard
  sleep [0.25, 0.5].choose
end
#+END_SRC

#+BEGIN_SRC ruby
loop do
  sample [:drum_cymbal_closed, :drum_cymbal_open].choose
  sleep [0.125, 0.25, 0.5].choose
end
#+END_SRC

#+BEGIN_SRC ruby
use_bpm 120

loop do
  8.times do
    sample :drum_cymbal_closed
    sleep 0.25
  end
  
  4.times do
    sample :drum_cymbal_open
    sleep [0.25, 0.5].choose
  end
end
#+END_SRC

* 4. MODULARITY / FUNCTION AS ARGUMENT FOR OTHER FUNCTIONS
- mover toda a sessão para cá, junto com randomização
- exemplo como

#+BEGIN_SRC ruby
sample :loop_amen
sleep sample_duration :loop_amen
sample :loop_amen

# já que
prints(sample_duration :loop_amen)
#+END_SRC

* BONUS STUFF!
** live_loop

#+BEGIN_SRC ruby
live_loop :myBDLoop do
  sample :drum_bass_hard
  sleep [0.5, 0.25].choose
end

live_loop :myCymbalLoop do
  stop
  sample :drum_cymbal_open
  sleep [0.125, 0.25].choose
end
#+END_SRC
